package scriptgen

// PlaywrightConfigTemplate generates playwright.config.ts
const PlaywrightConfigTemplate = `import { defineConfig, devices } from '@playwright/test';
import * as dotenv from 'dotenv';

dotenv.config();

const ENV = process.env.TEST_ENV || 'dev';

const envConfig: Record<string, { baseURL: string; timeout: number }> = {
  dev: {
    baseURL: process.env.DEV_URL || '{{.BaseURL}}',
    timeout: 30000,
  },
  staging: {
    baseURL: process.env.STAGING_URL || '{{.BaseURL}}',
    timeout: 45000,
  },
  prod: {
    baseURL: process.env.PROD_URL || '{{.BaseURL}}',
    timeout: 60000,
  },
};

export default defineConfig({
  testDir: './tests',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 4 : undefined,

  reporter: [
    ['list'],
    ['html', { outputFolder: 'reports/html', open: 'never' }],
    ['json', { outputFile: 'reports/results.json' }],
    ['junit', { outputFile: 'reports/junit.xml' }],
  ],

  use: {
    baseURL: envConfig[ENV].baseURL,
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure',
    actionTimeout: 10000,
    navigationTimeout: 30000,
  },

  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
    {
      name: 'mobile-chrome',
      use: { ...devices['Pixel 5'] },
    },
    {
      name: 'mobile-safari',
      use: { ...devices['iPhone 12'] },
    },
  ],

  // Output directories
  outputDir: 'test-results/',

  // Global setup/teardown
  // globalSetup: require.resolve('./fixtures/global-setup'),
  // globalTeardown: require.resolve('./fixtures/global-teardown'),
});
`

// PackageJSONTemplate generates package.json
const PackageJSONTemplate = `{
  "name": "{{.ProjectName}}-tests",
  "version": "1.0.0",
  "description": "Automated tests generated by TestForge",
  "scripts": {
    "test": "playwright test",
    "test:smoke": "playwright test --grep @smoke",
    "test:regression": "playwright test --grep @regression",
    "test:e2e": "playwright test --grep @e2e",
    "test:a11y": "playwright test --grep @accessibility",
    "test:security": "playwright test --grep @security",
    "test:ci": "CI=true playwright test",
    "test:headed": "playwright test --headed",
    "test:debug": "playwright test --debug",
    "test:ui": "playwright test --ui",
    "report": "playwright show-report reports/html",
    "lint": "eslint . --ext .ts",
    "format": "prettier --write .",
    "codegen": "playwright codegen"
  },
  "devDependencies": {
    "@playwright/test": "^1.40.0",
    "@axe-core/playwright": "^4.8.0",
    "@types/node": "^20.0.0",
    "typescript": "^5.0.0",
    "dotenv": "^16.0.0",
    "eslint": "^8.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "prettier": "^3.0.0"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "testforge": {
    "generatedAt": "{{.GeneratedAt}}",
    "suiteId": "{{.SuiteID}}",
    "version": "1.0.0"
  }
}
`

// TSConfigTemplate generates tsconfig.json
const TSConfigTemplate = `{
  "compilerOptions": {
    "target": "ES2022",
    "module": "commonjs",
    "moduleResolution": "node",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "./dist",
    "rootDir": ".",
    "declaration": true,
    "resolveJsonModule": true,
    "types": ["node"]
  },
  "include": [
    "**/*.ts"
  ],
  "exclude": [
    "node_modules",
    "dist",
    "reports",
    "test-results"
  ]
}
`

// EnvExampleTemplate generates .env.example
const EnvExampleTemplate = `# TestForge Generated Test Configuration
# Copy this file to .env and fill in values

# Environment (dev, staging, prod)
TEST_ENV=dev

# URLs
DEV_URL={{.BaseURL}}
STAGING_URL=
PROD_URL=

# Authentication (for authenticated tests)
TEST_USER=
TEST_PASSWORD=
TEST_ADMIN_USER=
TEST_ADMIN_PASSWORD=

# API Keys (if needed)
API_KEY=

# TestForge Integration
TESTFORGE_API_URL={{.APIEndpoint}}
TESTFORGE_RUN_ID={{.TestRunID}}
TESTFORGE_TENANT_ID={{.TenantID}}
`

// BasePageTemplate generates pages/base.page.ts
const BasePageTemplate = `import { Page, Locator, expect } from '@playwright/test';
import { ResilientSelector } from '../utils/selectors';

/**
 * Base page object class with common functionality
 * All page objects should extend this class
 */
export abstract class BasePage {
  constructor(protected page: Page) {}

  /**
   * The URL path for this page (relative to baseURL)
   */
  abstract readonly url: string;

  /**
   * Navigate to this page
   */
  async navigate(): Promise<void> {
    await this.page.goto(this.url);
    await this.waitForPageLoad();
  }

  /**
   * Wait for the page to be fully loaded
   */
  async waitForPageLoad(): Promise<void> {
    await this.page.waitForLoadState('networkidle');
  }

  /**
   * Wait for a specific element to be visible
   */
  async waitForElement(selector: ResilientSelector, timeout = 10000): Promise<Locator> {
    const locator = await selector.locate(this.page);
    await locator.waitFor({ state: 'visible', timeout });
    return locator;
  }

  /**
   * Click an element using resilient selector
   */
  protected async click(selector: ResilientSelector): Promise<void> {
    const locator = await selector.locate(this.page);
    await locator.click();
  }

  /**
   * Fill an input field using resilient selector
   */
  protected async fill(selector: ResilientSelector, value: string): Promise<void> {
    const locator = await selector.locate(this.page);
    await locator.fill(value);
  }

  /**
   * Clear and fill an input field
   */
  protected async clearAndFill(selector: ResilientSelector, value: string): Promise<void> {
    const locator = await selector.locate(this.page);
    await locator.clear();
    await locator.fill(value);
  }

  /**
   * Select an option from a dropdown
   */
  protected async select(selector: ResilientSelector, value: string): Promise<void> {
    const locator = await selector.locate(this.page);
    await locator.selectOption(value);
  }

  /**
   * Check a checkbox
   */
  protected async check(selector: ResilientSelector): Promise<void> {
    const locator = await selector.locate(this.page);
    await locator.check();
  }

  /**
   * Uncheck a checkbox
   */
  protected async uncheck(selector: ResilientSelector): Promise<void> {
    const locator = await selector.locate(this.page);
    await locator.uncheck();
  }

  /**
   * Get text content from an element
   */
  protected async getText(selector: ResilientSelector): Promise<string> {
    const locator = await selector.locate(this.page);
    return await locator.innerText();
  }

  /**
   * Get input value
   */
  protected async getValue(selector: ResilientSelector): Promise<string> {
    const locator = await selector.locate(this.page);
    return await locator.inputValue();
  }

  /**
   * Check if an element is visible
   */
  protected async isVisible(selector: ResilientSelector): Promise<boolean> {
    try {
      const locator = await selector.locate(this.page);
      return await locator.isVisible();
    } catch {
      return false;
    }
  }

  /**
   * Check if an element is enabled
   */
  protected async isEnabled(selector: ResilientSelector): Promise<boolean> {
    try {
      const locator = await selector.locate(this.page);
      return await locator.isEnabled();
    } catch {
      return false;
    }
  }

  /**
   * Hover over an element
   */
  protected async hover(selector: ResilientSelector): Promise<void> {
    const locator = await selector.locate(this.page);
    await locator.hover();
  }

  /**
   * Press a key
   */
  protected async pressKey(key: string): Promise<void> {
    await this.page.keyboard.press(key);
  }

  /**
   * Get current page URL
   */
  getURL(): string {
    return this.page.url();
  }

  /**
   * Get page title
   */
  async getTitle(): Promise<string> {
    return await this.page.title();
  }

  /**
   * Take a screenshot for visual comparison
   */
  async captureState(name: string): Promise<Buffer> {
    const screenshot = await this.page.screenshot({
      fullPage: true,
      path: ` + "`reports/screenshots/${name}.png`" + `,
    });
    return screenshot;
  }

  /**
   * Run accessibility check using axe-core
   */
  async checkA11y(options?: { includedImpacts?: string[] }): Promise<void> {
    const AxeBuilder = require('@axe-core/playwright').default;
    const results = await new AxeBuilder({ page: this.page })
      .withTags(['wcag2a', 'wcag2aa'])
      .analyze();

    if (options?.includedImpacts) {
      const filtered = results.violations.filter((v: any) =>
        options.includedImpacts!.includes(v.impact)
      );
      expect(filtered).toEqual([]);
    } else {
      expect(results.violations).toEqual([]);
    }
  }

  /**
   * Wait for network to be idle
   */
  async waitForNetworkIdle(): Promise<void> {
    await this.page.waitForLoadState('networkidle');
  }

  /**
   * Scroll to element
   */
  protected async scrollTo(selector: ResilientSelector): Promise<void> {
    const locator = await selector.locate(this.page);
    await locator.scrollIntoViewIfNeeded();
  }

  /**
   * Upload a file
   */
  protected async uploadFile(selector: ResilientSelector, filePath: string): Promise<void> {
    const locator = await selector.locate(this.page);
    await locator.setInputFiles(filePath);
  }
}
`

// SelectorsUtilTemplate generates utils/selectors.ts
const SelectorsUtilTemplate = `import { Page, Locator } from '@playwright/test';

/**
 * Represents a selector with fallback strategies for resilient element location
 */
export class ResilientSelector {
  constructor(
    public readonly primary: string,
    public readonly fallbacks: string[] = [],
    public readonly description: string = '',
    public readonly confidence: number = 1.0
  ) {}

  /**
   * Locate the element using primary selector first, then fallbacks
   * @param page - Playwright Page object
   * @returns Locator for the found element
   * @throws Error if no selector finds the element
   */
  async locate(page: Page): Promise<Locator> {
    // Try primary selector first
    const primary = page.locator(this.primary);
    if (await this.isLocatorValid(primary)) {
      return primary;
    }

    // Try fallback selectors
    for (const fallback of this.fallbacks) {
      const locator = page.locator(fallback);
      if (await this.isLocatorValid(locator)) {
        console.warn(` + "`[SELF-HEAL] Primary selector failed: ${this.primary}`" + `);
        console.warn(` + "`[SELF-HEAL] Using fallback: ${fallback}`" + `);
        // In production, this would report to TestForge for learning
        this.reportHealing(this.primary, fallback);
        return locator;
      }
    }

    // None found - throw descriptive error
    throw new Error(
      ` + "`Element not found: ${this.description}\\n`" + ` +
      ` + "`Primary: ${this.primary}\\n`" + ` +
      ` + "`Fallbacks: ${this.fallbacks.join(', ')}`" + `
    );
  }

  /**
   * Check if a locator points to at least one element
   */
  private async isLocatorValid(locator: Locator): Promise<boolean> {
    try {
      return (await locator.count()) > 0;
    } catch {
      return false;
    }
  }

  /**
   * Report a healing event for future learning
   */
  private reportHealing(failed: string, succeeded: string): void {
    // Store healing event for analysis
    const healingEvent = {
      timestamp: new Date().toISOString(),
      failedSelector: failed,
      healedSelector: succeeded,
      description: this.description,
    };

    // In CI, this would be sent to TestForge API
    if (process.env.TESTFORGE_API_URL) {
      // async report - don't await
      this.sendHealingReport(healingEvent).catch(console.error);
    }
  }

  /**
   * Send healing report to TestForge API
   */
  private async sendHealingReport(event: any): Promise<void> {
    try {
      await fetch(` + "`${process.env.TESTFORGE_API_URL}/healing-events`" + `, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(event),
      });
    } catch (error) {
      console.warn('Failed to report healing event:', error);
    }
  }

  /**
   * Create a ResilientSelector from a simple string
   */
  static from(selector: string, description = ''): ResilientSelector {
    return new ResilientSelector(selector, [], description, 1.0);
  }

  /**
   * Create a ResilientSelector with common fallback patterns
   */
  static withFallbacks(
    primary: string,
    fallbacks: string[],
    description = ''
  ): ResilientSelector {
    return new ResilientSelector(primary, fallbacks, description, 0.8);
  }
}

/**
 * Common selector builders
 */
export const Selectors = {
  /** Select by data-testid attribute */
  byTestId: (id: string, description = ''): ResilientSelector =>
    new ResilientSelector(
      ` + "`[data-testid=\"${id}\"]`" + `,
      [` + "`[data-test=\"${id}\"]`" + `, ` + "`[data-cy=\"${id}\"]`" + `],
      description,
      1.0
    ),

  /** Select by ID attribute */
  byId: (id: string, description = ''): ResilientSelector =>
    new ResilientSelector(
      ` + "`#${id}`" + `,
      [` + "`[id=\"${id}\"]`" + `],
      description,
      0.9
    ),

  /** Select by aria-label */
  byAriaLabel: (label: string, description = ''): ResilientSelector =>
    new ResilientSelector(
      ` + "`[aria-label=\"${label}\"]`" + `,
      [` + "`[aria-labelledby=\"${label}\"]`" + `],
      description,
      0.9
    ),

  /** Select by role */
  byRole: (role: string, name?: string, description = ''): ResilientSelector => {
    const primary = name
      ? ` + "`role=${role}[name=\"${name}\"]`" + `
      : ` + "`role=${role}`" + `;
    return new ResilientSelector(primary, [], description, 0.9);
  },

  /** Select by text content */
  byText: (text: string, description = ''): ResilientSelector =>
    new ResilientSelector(
      ` + "`text=\"${text}\"`" + `,
      [` + "`text=${text}`" + `, ` + "`*:has-text(\"${text}\")`" + `],
      description,
      0.7
    ),

  /** Select by placeholder */
  byPlaceholder: (placeholder: string, description = ''): ResilientSelector =>
    new ResilientSelector(
      ` + "`[placeholder=\"${placeholder}\"]`" + `,
      [` + "`input[placeholder*=\"${placeholder}\"]`" + `],
      description,
      0.8
    ),

  /** Select by name attribute */
  byName: (name: string, description = ''): ResilientSelector =>
    new ResilientSelector(
      ` + "`[name=\"${name}\"]`" + `,
      [` + "`input[name=\"${name}\"]`" + `, ` + "`*[name=\"${name}\"]`" + `],
      description,
      0.8
    ),

  /** Select submit button */
  submitButton: (description = 'Submit button'): ResilientSelector =>
    new ResilientSelector(
      'button[type="submit"]',
      ['input[type="submit"]', 'button:has-text("Submit")', '.submit-btn'],
      description,
      0.8
    ),
};
`

// AuthFixtureTemplate generates fixtures/auth.fixture.ts
const AuthFixtureTemplate = `import { test as base, Page, BrowserContext } from '@playwright/test';
import * as fs from 'fs';
import * as path from 'path';

/**
 * Custom fixtures for authenticated testing
 */
type AuthFixtures = {
  /** Page with regular user authentication */
  authenticatedPage: Page;
  /** Page with admin authentication */
  adminPage: Page;
  /** Page without authentication (guest) */
  guestPage: Page;
  /** Browser context with user auth */
  userContext: BrowserContext;
  /** Browser context with admin auth */
  adminContext: BrowserContext;
};

/**
 * Storage state file paths
 */
const AUTH_DIR = path.join(__dirname, '../auth');
const USER_AUTH = path.join(AUTH_DIR, 'user.json');
const ADMIN_AUTH = path.join(AUTH_DIR, 'admin.json');

/**
 * Extended test with authentication fixtures
 */
export const test = base.extend<AuthFixtures>({
  authenticatedPage: async ({ browser }, use) => {
    let context: BrowserContext;

    if (fs.existsSync(USER_AUTH)) {
      context = await browser.newContext({
        storageState: USER_AUTH,
      });
    } else {
      // Create new context and perform login
      context = await browser.newContext();
      const page = await context.newPage();
      await performLogin(page, process.env.TEST_USER!, process.env.TEST_PASSWORD!);

      // Save storage state for reuse
      await ensureAuthDir();
      await context.storageState({ path: USER_AUTH });
    }

    const page = await context.newPage();
    await use(page);
    await context.close();
  },

  adminPage: async ({ browser }, use) => {
    let context: BrowserContext;

    if (fs.existsSync(ADMIN_AUTH)) {
      context = await browser.newContext({
        storageState: ADMIN_AUTH,
      });
    } else {
      context = await browser.newContext();
      const page = await context.newPage();
      await performLogin(page, process.env.TEST_ADMIN_USER!, process.env.TEST_ADMIN_PASSWORD!);

      await ensureAuthDir();
      await context.storageState({ path: ADMIN_AUTH });
    }

    const page = await context.newPage();
    await use(page);
    await context.close();
  },

  guestPage: async ({ browser }, use) => {
    const context = await browser.newContext();
    const page = await context.newPage();
    await use(page);
    await context.close();
  },

  userContext: async ({ browser }, use) => {
    const context = fs.existsSync(USER_AUTH)
      ? await browser.newContext({ storageState: USER_AUTH })
      : await browser.newContext();
    await use(context);
    await context.close();
  },

  adminContext: async ({ browser }, use) => {
    const context = fs.existsSync(ADMIN_AUTH)
      ? await browser.newContext({ storageState: ADMIN_AUTH })
      : await browser.newContext();
    await use(context);
    await context.close();
  },
});

/**
 * Perform login flow
 */
async function performLogin(page: Page, username: string, password: string): Promise<void> {
  // Navigate to login page
  await page.goto('/login');

  // Fill credentials - using common selectors
  const usernameSelectors = ['#username', '#email', 'input[name="username"]', 'input[name="email"]'];
  const passwordSelectors = ['#password', 'input[name="password"]', 'input[type="password"]'];
  const submitSelectors = ['button[type="submit"]', 'input[type="submit"]', '.login-btn'];

  // Try username selectors
  for (const selector of usernameSelectors) {
    if (await page.locator(selector).count() > 0) {
      await page.locator(selector).fill(username);
      break;
    }
  }

  // Try password selectors
  for (const selector of passwordSelectors) {
    if (await page.locator(selector).count() > 0) {
      await page.locator(selector).fill(password);
      break;
    }
  }

  // Try submit selectors
  for (const selector of submitSelectors) {
    if (await page.locator(selector).count() > 0) {
      await page.locator(selector).click();
      break;
    }
  }

  // Wait for login to complete
  await page.waitForLoadState('networkidle');
}

/**
 * Ensure auth directory exists
 */
async function ensureAuthDir(): Promise<void> {
  if (!fs.existsSync(AUTH_DIR)) {
    fs.mkdirSync(AUTH_DIR, { recursive: true });
  }
}

export { expect } from '@playwright/test';
`

// TestDataTemplate generates fixtures/test-data.ts
const TestDataTemplate = `/**
 * Test data for different environments and scenarios
 * Generated by TestForge
 */

export interface TestDataConfig {
  env: string;
  baseURL: string;
  users: {
    regular: UserData;
    admin: UserData;
    guest: UserData;
  };
  forms: Record<string, FormData>;
  api: {
    timeout: number;
    retries: number;
  };
}

export interface UserData {
  username: string;
  password: string;
  email: string;
  displayName: string;
}

export interface FormData {
  [key: string]: string | number | boolean;
}

/**
 * Environment-specific test data
 */
const testData: Record<string, TestDataConfig> = {
  dev: {
    env: 'dev',
    baseURL: process.env.DEV_URL || '{{.BaseURL}}',
    users: {
      regular: {
        username: process.env.TEST_USER || 'testuser',
        password: process.env.TEST_PASSWORD || 'testpass123',
        email: 'testuser@example.com',
        displayName: 'Test User',
      },
      admin: {
        username: process.env.TEST_ADMIN_USER || 'admin',
        password: process.env.TEST_ADMIN_PASSWORD || 'adminpass123',
        email: 'admin@example.com',
        displayName: 'Admin User',
      },
      guest: {
        username: '',
        password: '',
        email: '',
        displayName: 'Guest',
      },
    },
    forms: {
      contact: {
        name: 'John Doe',
        email: 'john@example.com',
        message: 'This is a test message',
      },
      search: {
        query: 'test search query',
      },
    },
    api: {
      timeout: 30000,
      retries: 3,
    },
  },
  staging: {
    env: 'staging',
    baseURL: process.env.STAGING_URL || '{{.BaseURL}}',
    users: {
      regular: {
        username: process.env.TEST_USER || 'staging_user',
        password: process.env.TEST_PASSWORD || 'stagingpass123',
        email: 'staging@example.com',
        displayName: 'Staging User',
      },
      admin: {
        username: process.env.TEST_ADMIN_USER || 'staging_admin',
        password: process.env.TEST_ADMIN_PASSWORD || 'stagingadmin123',
        email: 'staging_admin@example.com',
        displayName: 'Staging Admin',
      },
      guest: {
        username: '',
        password: '',
        email: '',
        displayName: 'Guest',
      },
    },
    forms: {
      contact: {
        name: 'Staging User',
        email: 'staging@example.com',
        message: 'Staging test message',
      },
      search: {
        query: 'staging search',
      },
    },
    api: {
      timeout: 45000,
      retries: 2,
    },
  },
  prod: {
    env: 'prod',
    baseURL: process.env.PROD_URL || '{{.BaseURL}}',
    users: {
      regular: {
        username: process.env.TEST_USER || '',
        password: process.env.TEST_PASSWORD || '',
        email: '',
        displayName: 'Production User',
      },
      admin: {
        username: process.env.TEST_ADMIN_USER || '',
        password: process.env.TEST_ADMIN_PASSWORD || '',
        email: '',
        displayName: 'Production Admin',
      },
      guest: {
        username: '',
        password: '',
        email: '',
        displayName: 'Guest',
      },
    },
    forms: {
      contact: {
        name: '',
        email: '',
        message: '',
      },
      search: {
        query: '',
      },
    },
    api: {
      timeout: 60000,
      retries: 1,
    },
  },
};

/**
 * Get test data for current environment
 */
export function getTestData(): TestDataConfig {
  const env = process.env.TEST_ENV || 'dev';
  return testData[env] || testData.dev;
}

/**
 * Get user data by role
 */
export function getUser(role: 'regular' | 'admin' | 'guest'): UserData {
  return getTestData().users[role];
}

/**
 * Get form data by name
 */
export function getFormData(formName: string): FormData | undefined {
  return getTestData().forms[formName];
}

/**
 * Generate random test data
 */
export const RandomData = {
  email: () => ` + "`test_${Date.now()}@example.com`" + `,
  username: () => ` + "`user_${Date.now()}`" + `,
  password: () => ` + "`Pass_${Date.now()}_!`" + `,
  string: (length = 10) => {
    const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
    return Array.from({ length }, () => chars[Math.floor(Math.random() * chars.length)]).join('');
  },
  number: (min = 0, max = 100) => Math.floor(Math.random() * (max - min + 1)) + min,
  phone: () => ` + "`+1${RandomData.number(100, 999)}${RandomData.number(100, 999)}${RandomData.number(1000, 9999)}`" + `,
};
`

// AssertionsUtilTemplate generates utils/assertions.ts
const AssertionsUtilTemplate = `import { expect, Page, Locator } from '@playwright/test';
import { ResilientSelector } from './selectors';

/**
 * Custom assertion helpers for common test scenarios
 */
export const Assertions = {
  /**
   * Assert element is visible with resilient selector
   */
  async visible(page: Page, selector: ResilientSelector, options?: { timeout?: number }): Promise<void> {
    const locator = await selector.locate(page);
    await expect(locator).toBeVisible(options);
  },

  /**
   * Assert element is hidden
   */
  async hidden(page: Page, selector: ResilientSelector): Promise<void> {
    const locator = await selector.locate(page);
    await expect(locator).toBeHidden();
  },

  /**
   * Assert element contains text
   */
  async containsText(page: Page, selector: ResilientSelector, text: string): Promise<void> {
    const locator = await selector.locate(page);
    await expect(locator).toContainText(text);
  },

  /**
   * Assert element has exact text
   */
  async hasText(page: Page, selector: ResilientSelector, text: string): Promise<void> {
    const locator = await selector.locate(page);
    await expect(locator).toHaveText(text);
  },

  /**
   * Assert input has value
   */
  async hasValue(page: Page, selector: ResilientSelector, value: string): Promise<void> {
    const locator = await selector.locate(page);
    await expect(locator).toHaveValue(value);
  },

  /**
   * Assert element has attribute
   */
  async hasAttribute(page: Page, selector: ResilientSelector, name: string, value?: string): Promise<void> {
    const locator = await selector.locate(page);
    if (value !== undefined) {
      await expect(locator).toHaveAttribute(name, value);
    } else {
      await expect(locator).toHaveAttribute(name);
    }
  },

  /**
   * Assert element has CSS class
   */
  async hasClass(page: Page, selector: ResilientSelector, className: string): Promise<void> {
    const locator = await selector.locate(page);
    await expect(locator).toHaveClass(new RegExp(className));
  },

  /**
   * Assert element is enabled
   */
  async enabled(page: Page, selector: ResilientSelector): Promise<void> {
    const locator = await selector.locate(page);
    await expect(locator).toBeEnabled();
  },

  /**
   * Assert element is disabled
   */
  async disabled(page: Page, selector: ResilientSelector): Promise<void> {
    const locator = await selector.locate(page);
    await expect(locator).toBeDisabled();
  },

  /**
   * Assert element is checked (checkbox/radio)
   */
  async checked(page: Page, selector: ResilientSelector): Promise<void> {
    const locator = await selector.locate(page);
    await expect(locator).toBeChecked();
  },

  /**
   * Assert element count
   */
  async count(page: Page, selector: ResilientSelector, expectedCount: number): Promise<void> {
    const locator = await selector.locate(page);
    await expect(locator).toHaveCount(expectedCount);
  },

  /**
   * Assert page URL contains string
   */
  async urlContains(page: Page, substring: string): Promise<void> {
    await expect(page).toHaveURL(new RegExp(substring));
  },

  /**
   * Assert page URL equals
   */
  async urlEquals(page: Page, url: string): Promise<void> {
    await expect(page).toHaveURL(url);
  },

  /**
   * Assert page title
   */
  async pageTitle(page: Page, title: string | RegExp): Promise<void> {
    await expect(page).toHaveTitle(title);
  },

  /**
   * Assert no console errors
   */
  async noConsoleErrors(page: Page, errors: string[]): Promise<void> {
    const criticalErrors = errors.filter(
      (e) => e.includes('Error') || e.includes('error') || e.includes('fail')
    );
    expect(criticalErrors).toHaveLength(0);
  },

  /**
   * Assert API response status
   */
  async apiStatus(response: { status: () => number }, expectedStatus: number): Promise<void> {
    expect(response.status()).toBe(expectedStatus);
  },

  /**
   * Assert element focused
   */
  async focused(page: Page, selector: ResilientSelector): Promise<void> {
    const locator = await selector.locate(page);
    await expect(locator).toBeFocused();
  },

  /**
   * Assert screenshot matches (visual regression)
   */
  async matchesSnapshot(page: Page, name: string): Promise<void> {
    await expect(page).toHaveScreenshot(` + "`${name}.png`" + `, {
      maxDiffPixels: 100,
    });
  },
};
`

// GitignoreTemplate generates .gitignore
const GitignoreTemplate = `# Dependencies
node_modules/

# Build output
dist/

# Test results
test-results/
reports/
playwright-report/

# Auth state (sensitive)
auth/

# Environment files
.env
.env.local

# IDE
.idea/
.vscode/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
*.log
npm-debug.log*
`

// ReadmeTemplate generates README.md
const ReadmeTemplate = `# {{.ProjectName}} - Automated Tests

Generated by TestForge on {{.GeneratedAt}}

## Quick Start

` + "```bash" + `
# Install dependencies
npm install

# Install browsers
npx playwright install

# Run all tests
npm test

# Run specific test types
npm run test:smoke
npm run test:regression
npm run test:e2e
npm run test:a11y
` + "```" + `

## Project Structure

` + "```" + `
├── tests/               # Test files
│   ├── smoke/           # Smoke tests (critical path)
│   ├── regression/      # Full regression tests
│   ├── e2e/             # End-to-end flows
│   ├── accessibility/   # WCAG compliance tests
│   └── security/        # Security tests
├── pages/               # Page Object Models
├── fixtures/            # Test fixtures & data
├── utils/               # Utility functions
└── reports/             # Generated reports
` + "```" + `

## Configuration

1. Copy ` + "`.env.example`" + ` to ` + "`.env`" + `
2. Fill in your environment-specific values
3. Run tests with: ` + "`TEST_ENV=staging npm test`" + `

## Test Statistics

- Features: {{.TotalFeatures}}
- Scenarios: {{.TotalScenarios}}
- Test Cases: {{.TotalTests}}
- Test Steps: {{.TotalSteps}}

## Reports

After running tests, view the HTML report:
` + "```bash" + `
npm run report
` + "```" + `
`
